---
# Spotizerr Helm Chart Values for sabkhi_lab
# Configuration based on docker-compose setup

spotizerr:
  image:
    repository: cooldockerizer93/spotizerr
    tag: "latest"
    pullPolicy: Always  # Use Always to get latest updates
  
  # Security context matching docker-compose user:group 1000:1000
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  
  # Resource configuration
  resources:
    requests:
      cpu: 200m
      memory: 700Mi
    limits: {}  # Explicitly remove limits (chart defaults to 1000m CPU / 1Gi memory)
  
  # Service configuration
  service:
    type: ClusterIP
    port: 7171
    targetPort: 7171
  
  # Persistent storage - using existing PVCs that will be created separately
  persistence:
    enabled: true
    storageClassName: "longhorn-ssd-replicated"
    
    # Data volume (config, creds, watch, history)
    data:
      enabled: true
      size: 1Gi
      existingClaim: "spotizerr-data"  # Using existing PVC to preserve data
    
    # Downloads volume - shared with Navidrome via music-library PVC
    downloads:
      enabled: true
      size: 50Gi  # Size ignored when using existingClaim
      existingClaim: "music-library"  # Shared music library PVC (media namespace)
    
    # Logs volume
    logs:
      enabled: true
      size: 2Gi
      existingClaim: "spotizerr-logs"  # Using existing PVC to preserve data
    
    # Cache volume
    # Note: Mounted to /app/cache-volume instead of /app/.cache
    # because .cache is a file in the image, not a directory
    cache:
      enabled: true
      size: 500Mi
      existingClaim: "spotizerr-cache"  # Using existing PVC to preserve data
  
  # Environment variables from .env file
  env:
    HOST: "0.0.0.0"
    PORT: "7171"
    LOG_LEVEL: "INFO"
    EXPLICIT_FILTER: "false"
    START_EMBEDDED_WORKERS: "true"
    REDIS_DB: "0"
    UMASK: "0022"
    SKIP_SET_PERMISSIONS: "false"
    # Authentication settings
    ENABLE_AUTH: "false"  # Set to true if you want multi-user mode
    JWT_EXPIRATION_HOURS: "720"
    DEFAULT_ADMIN_USERNAME: "admin"
    DISABLE_REGISTRATION: "false"
    # SSO settings (disabled by default)
    SSO_ENABLED: "false"
    # Frontend URL for SSO
    # FRONTEND_URL: "https://spotizerr.internal.rmsz005.com"
    # SSO_BASE_REDIRECT_URI: "https://spotizerr.internal.rmsz005.com/api/auth/sso/callback"
  
  # Note: REDIS_HOST, REDIS_PORT, and REDIS_PASSWORD are automatically
  # injected by the chart template when redis.enabled=true
  # See chart/templates/deployment.yaml lines 48-57
  
  # Secrets - additional app secrets via SealedSecrets (if needed)
  secrets: {}
    # JWT_SECRET: ""  # Set via sealed-secret if ENABLE_AUTH=true
    # DEFAULT_ADMIN_PASSWORD: ""  # Set via sealed-secret if ENABLE_AUTH=true
    # GOOGLE_CLIENT_ID: ""  # Set via sealed-secret if SSO_ENABLED=true
    # GOOGLE_CLIENT_SECRET: ""
    # GITHUB_CLIENT_ID: ""
    # GITHUB_CLIENT_SECRET: ""
  
  # Health checks
  livenessProbe:
    enabled: true
    httpGet:
      path: /
      port: 7171
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  
  readinessProbe:
    enabled: true
    httpGet:
      path: /
      port: 7171
    initialDelaySeconds: 30
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

# Redis configuration (embedded)
redis:
  enabled: true
  
  image:
    repository: redis
    tag: "alpine"
    pullPolicy: IfNotPresent
  
  # Redis password via sealed secret
  existingSecret: "spotizerr-redis-secret"
  existingSecretPasswordKey: "redis-password"
  # password: "changeme"  # Only used if existingSecret is not set
  
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
  
  service:
    type: ClusterIP
    port: 6379
  
  persistence:
    enabled: true
    storageClassName: "longhorn-ssd-replicated"
    size: 2Gi
    existingClaim: "spotizerr-redis"  # Using existing PVC to preserve data
  
  args:
    appendonly: true

# Ingress configuration for external access
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt"
    cert-manager.io/common-name: "spotizerr.internal.rmsz005.com"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"  # Allow large file uploads
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    # SSE (Server-Sent Events) support for real-time download status updates
    nginx.ingress.kubernetes.io/proxy-buffering: "off"  # Disable buffering for SSE
    nginx.ingress.kubernetes.io/proxy-cache-control: "no-cache"  # Prevent caching SSE streams
    nginx.ingress.kubernetes.io/proxy-http-version: "1.1"  # HTTP/1.1 for SSE
    # Note: configuration-snippet removed as it's blocked by NGINX ingress controller security policy
    # The above standard annotations provide the same SSE functionality
  hosts:
    - host: spotizerr.internal.rmsz005.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: spotizerr-tls
      hosts:
        - spotizerr.internal.rmsz005.com

# Service Account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod annotations (for Prometheus if needed)
podAnnotations: {}
  # prometheus.io/scrape: "true"
  # prometheus.io/port: "7171"
  # prometheus.io/path: "/metrics"

# Pod security context
podSecurityContext:
  fsGroup: 1000

# Node selector - adjust if you have specific node labels
nodeSelector: {}
  # kubernetes.io/hostname: specific-node

# Tolerations
tolerations: []

# Affinity rules
affinity: {}

# Number of replicas (keep at 1 for stateful applications)
replicaCount: 1

# Image pull secrets
imagePullSecrets: []

# Additional labels
commonLabels:
  app: spotizerr

